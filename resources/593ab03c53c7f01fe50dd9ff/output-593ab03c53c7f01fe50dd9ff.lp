{:exit 0, :out "['perm', ['go_home', ['R']]]\n{'cond': ['role', ['R', 'hero']], 'xinitiates': [[['intStartExample1', []], [['perm', ['go_home', ['R']]]], ['role', ['R', 'hero']]], [['intStartExample1', []], [['phase', ['example1', 'active']]], []]], 'x': ['perm', ['go_home', ['R']]], 'sinst': 'killNSearch', 'vars1': {'R': 'Agent'}, 'rl': [['intStartExample1', []], [['perm', ['go_home', ['R']]]], ['role', ['R', 'hero']]], 'df': [['perm', ['go_home', ['R']]]], 'self': <instal.compiler.newcompiler.instaliabcompiler.InstalBridgeCompiler object at 0x7f4ae76b7e10>, 'vars2': {'R': 'Agent'}, 'y': 'intStartExample1', 'dinst': 'example1', 'sf': ['intStartExample1', []]}\n['phase', ['example1', 'active']]\n{'cond': [], 'k': 'R', 'xinitiates': [[['intStartExample1', []], [['perm', ['go_home', ['R']]]], ['role', ['R', 'hero']]], [['intStartExample1', []], [['phase', ['example1', 'active']]], []]], 'x': ['phase', ['example1', 'active']], 'sinst': 'killNSearch', 'vars1': {}, 'rl': [['intStartExample1', []], [['phase', ['example1', 'active']]], []], 'df': [['phase', ['example1', 'active']]], 'self': <instal.compiler.newcompiler.instaliabcompiler.InstalBridgeCompiler object at 0x7f4ae76b7e10>, 'vars2': {}, 'y': 'intStartExample1', 'dinst': 'example1', 'sf': ['intStartExample1', []]}\n%\n% Rules for Bridge killNSearchExample1\n%\n  ifluent(live(killNSearchExample1), killNSearchExample1).\n  fluent(live(killNSearchExample1), killNSearchExample1).\n  bridge(killNSearchExample1).\n  sink(example1, killNSearchExample1).\n  source(killNSearch, killNSearchExample1). \n  :- not _preludeLoaded. \n\nfluent(ipow(killNSearch,phase(Trope,Phase),example1), killNSearchExample1) :- \n    inst(killNSearch), source(killNSearch, killNSearchExample1), inst(example1), sink(example1, killNSearchExample1), bridge(killNSearchExample1), \n\n   phase(Phase),\n   trope(Trope),\n    fluent(phase(Trope,Phase), example1).\nifluent(ipow(killNSearch,phase(Trope,Phase),example1), killNSearchExample1) :- \n    inst(killNSearch), source(killNSearch, killNSearchExample1), inst(example1), sink(example1, killNSearchExample1), bridge(killNSearchExample1), \n\n   phase(Phase),\n   trope(Trope),\n    fluent(phase(Trope,Phase), example1).\nfluent(ipow(killNSearch,perm(go_home(Agent)),example1), killNSearchExample1) :- \n    inst(killNSearch), source(killNSearch, killNSearchExample1), inst(example1), sink(example1, killNSearchExample1), bridge(killNSearchExample1), \n\n   agent(Agent),\n    fluent(perm(go_home(Agent)), example1).\nifluent(ipow(killNSearch,perm(go_home(Agent)),example1), killNSearchExample1) :- \n    inst(killNSearch), source(killNSearch, killNSearchExample1), inst(example1), sink(example1, killNSearchExample1), bridge(killNSearchExample1), \n\n   agent(Agent),\n    fluent(perm(go_home(Agent)), example1).\n%\n% cross generate rules\n%\n%\n% cross initiation rules\n%\n%\n% Translation of intStartExample1 of killNSearch xinitiates ['perm', ['go_home', ['R']]] of example1 if ['role', ['R', 'hero']]\n%\nxinitiated(killNSearch, perm(go_home(R)),example1,I) :-\n   occurred(intStartExample1,killNSearch,I),\n   holdsat(ipow(killNSearch, perm(go_home(R)), example1), killNSearchExample1, I), \n   holdsat(live(killNSearchExample1),killNSearchExample1,I), bridge(killNSearchExample1), \n   inst(example1), inst(killNSearch), \n   holdsat(role(R,hero),killNSearch,I),\n   agent(R),\n   bridge(killNSearchExample1), instant(I).\n%\n% Translation of intStartExample1 of killNSearch xinitiates ['phase', ['example1', 'active']] of example1 if []\n%\nxinitiated(killNSearch, phase(example1,active),example1,I) :-\n   occurred(intStartExample1,killNSearch,I),\n   holdsat(ipow(killNSearch, phase(example1,active), example1), killNSearchExample1, I), \n   holdsat(live(killNSearchExample1),killNSearchExample1,I), bridge(killNSearchExample1), \n   inst(example1), inst(killNSearch), \n   bridge(killNSearchExample1), instant(I).\n%\n% cross termination rules\n%\n%\n% initially\n%\n% no creation event\nholdsat(live(killNSearchExample1),killNSearchExample1,I) :- start(I), bridge(killNSearchExample1).\nholdsat(perm(null),killNSearchExample1,I) :- start(I), bridge(killNSearchExample1).\n% initially: ipow(killNSearch,perm(go_home(R)),example1)\nholdsat(ipow(killNSearch,perm(go_home(R)),example1),killNSearchExample1,I) :- not holdsat(live(killNSearchExample1),killNSearchExample1),\n   agent(R),\n   bridge(killNSearchExample1), source(killNSearch, killNSearchExample1), sink(example1, killNSearchExample1), start(I).\n% initially: ipow(killNSearch,phase(example1,active),example1)\nholdsat(ipow(killNSearch,phase(example1,active),example1),killNSearchExample1,I) :- not holdsat(live(killNSearchExample1),killNSearchExample1),\n   bridge(killNSearchExample1), source(killNSearch, killNSearchExample1), sink(example1, killNSearchExample1), start(I).\n\nThere are 6 answer sets\n", :err ""}