{:exit 0, :out "['perm', ['go', ['R', 'V']]]\n{'x': ['perm', ['go', ['R', 'V']]], 'vars1': {'R': 'Agent', 'V': 'PlaceName'}, 'y': 'intStartExample3', 'sinst': 'newTrope', 'self': <instal.compiler.newcompiler.instaliabcompiler.InstalBridgeCompiler object at 0x7f664be8a4a8>, 'rl': [['intStartExample3', []], [['perm', ['go', ['R', 'V']]]], ['and', ['role', ['R', 'hero']], ['place', ['V', 'home']]]], 'cond': ['and', ['role', ['R', 'hero']], ['place', ['V', 'home']]], 'df': [['perm', ['go', ['R', 'V']]]], 'xinitiates': [[['intStartExample3', []], [['perm', ['go', ['R', 'V']]]], ['and', ['role', ['R', 'hero']], ['place', ['V', 'home']]]], [['intStartExample3', []], [['phase', ['example3', 'active']]], []]], 'vars2': {'R': 'Agent', 'V': 'PlaceName'}, 'dinst': 'example3', 'sf': ['intStartExample3', []]}\n['phase', ['example3', 'active']]\n{'x': ['phase', ['example3', 'active']], 'vars1': {}, 'y': 'intStartExample3', 'sinst': 'newTrope', 'self': <instal.compiler.newcompiler.instaliabcompiler.InstalBridgeCompiler object at 0x7f664be8a4a8>, 'rl': [['intStartExample3', []], [['phase', ['example3', 'active']]], []], 'cond': [], 'df': [['phase', ['example3', 'active']]], 'xinitiates': [[['intStartExample3', []], [['perm', ['go', ['R', 'V']]]], ['and', ['role', ['R', 'hero']], ['place', ['V', 'home']]]], [['intStartExample3', []], [['phase', ['example3', 'active']]], []]], 'vars2': {}, 'dinst': 'example3', 'k': 'V', 'sf': ['intStartExample3', []]}\n%\n% Rules for Bridge newTropeExample3\n%\n  ifluent(live(newTropeExample3), newTropeExample3).\n  fluent(live(newTropeExample3), newTropeExample3).\n  bridge(newTropeExample3).\n  sink(example3, newTropeExample3).\n  source(newTrope, newTropeExample3). \n  :- not _preludeLoaded. \n\nfluent(ipow(newTrope,phase(Trope,Phase),example3), newTropeExample3) :- \n    inst(newTrope), source(newTrope, newTropeExample3), inst(example3), sink(example3, newTropeExample3), bridge(newTropeExample3), \n\n   trope(Trope),\n   phase(Phase),\n    fluent(phase(Trope,Phase), example3).\nifluent(ipow(newTrope,phase(Trope,Phase),example3), newTropeExample3) :- \n    inst(newTrope), source(newTrope, newTropeExample3), inst(example3), sink(example3, newTropeExample3), bridge(newTropeExample3), \n\n   trope(Trope),\n   phase(Phase),\n    fluent(phase(Trope,Phase), example3).\nfluent(ipow(newTrope,perm(go(Agent,PlaceName)),example3), newTropeExample3) :- \n    inst(newTrope), source(newTrope, newTropeExample3), inst(example3), sink(example3, newTropeExample3), bridge(newTropeExample3), \n\n   placename(PlaceName),\n   agent(Agent),\n    fluent(perm(go(Agent,PlaceName)), example3).\nifluent(ipow(newTrope,perm(go(Agent,PlaceName)),example3), newTropeExample3) :- \n    inst(newTrope), source(newTrope, newTropeExample3), inst(example3), sink(example3, newTropeExample3), bridge(newTropeExample3), \n\n   placename(PlaceName),\n   agent(Agent),\n    fluent(perm(go(Agent,PlaceName)), example3).\n%\n% cross generate rules\n%\n%\n% cross initiation rules\n%\n%\n% Translation of intStartExample3 of newTrope xinitiates ['perm', ['go', ['R', 'V']]] of example3 if ['and', ['role', ['R', 'hero']], ['place', ['V', 'home']]]\n%\nxinitiated(newTrope, perm(go(R,V)),example3,I) :-\n   occurred(intStartExample3,newTrope,I),\n   holdsat(ipow(newTrope, perm(go(R,V)), example3), newTropeExample3, I), \n   holdsat(live(newTropeExample3),newTropeExample3,I), bridge(newTropeExample3), \n   inst(example3), inst(newTrope), \n   holdsat(role(R,hero),None,I),\n   holdsat(place(V,home),None,I),\n   agent(R),\n   placename(V),\n   bridge(newTropeExample3), instant(I).\n%\n% Translation of intStartExample3 of newTrope xinitiates ['phase', ['example3', 'active']] of example3 if []\n%\nxinitiated(newTrope, phase(example3,active),example3,I) :-\n   occurred(intStartExample3,newTrope,I),\n   holdsat(ipow(newTrope, phase(example3,active), example3), newTropeExample3, I), \n   holdsat(live(newTropeExample3),newTropeExample3,I), bridge(newTropeExample3), \n   inst(example3), inst(newTrope), \n   bridge(newTropeExample3), instant(I).\n%\n% cross termination rules\n%\n%\n% initially\n%\n% no creation event\nholdsat(live(newTropeExample3),newTropeExample3,I) :- start(I), bridge(newTropeExample3).\nholdsat(perm(null),newTropeExample3,I) :- start(I), bridge(newTropeExample3).\n% initially: ipow(newTrope,perm(go(R,V)),example3)\nholdsat(ipow(newTrope,perm(go(R,V)),example3),newTropeExample3,I) :- not holdsat(live(newTropeExample3),newTropeExample3),\n   agent(R),\n   placename(V),\n   bridge(newTropeExample3), source(newTrope, newTropeExample3), sink(example3, newTropeExample3), start(I).\n% initially: ipow(newTrope,phase(example3,active),example3)\nholdsat(ipow(newTrope,phase(example3,active),example3),newTropeExample3,I) :- not holdsat(live(newTropeExample3),newTropeExample3),\n   bridge(newTropeExample3), source(newTrope, newTropeExample3), sink(example3, newTropeExample3), start(I).\n\nThere are 9 answer sets\n", :err ""}